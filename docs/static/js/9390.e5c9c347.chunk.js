"use strict";(self.webpackChunkbrewjs_for_react_router_example=self.webpackChunkbrewjs_for_react_router_example||[]).push([[9390],{9390:function(e,n,r){r.r(n);var s=r(2556);function t(e){const n=Object.assign({h1:"h1",p:"p",h2:"h2",code:"code",ul:"ul",li:"li",ol:"ol",table:"table",thead:"thead",tr:"tr",th:"th",tbody:"tbody",td:"td",blockquote:"blockquote",strong:"strong"},e.components),{Module:r,WaterpipeExample:t}=n;return r||a("Module",!0),t||a("WaterpipeExample",!0),(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(r,{name:"waterpipe"}),"\n",(0,s.jsx)(n.h1,{children:"Transforming data"}),"\n",(0,s.jsx)(n.p,{children:"A pipe consists of a list of arguemnts separated by spaces, where the\r\nfirst arguemnt is typically inferred as input value."}),"\n",(0,s.jsx)(n.h2,{children:"Pipe function"}),"\n",(0,s.jsx)(n.p,{children:"For any next argument, pipe function will be looked up by the name."}),"\n",(0,s.jsx)(n.p,{children:"A pipe function takes an input value and a fixed or dynamic number of arguments."}),"\n",(0,s.jsx)(t,{data:{values:[1,2,3,4]},examples:["values length","values where odd"]}),"\n",(0,s.jsxs)(n.p,{children:["In the above example, ",(0,s.jsx)(n.code,{children:"values"})," is the input and ",(0,s.jsx)(n.code,{children:"length"})," and ",(0,s.jsx)(n.code,{children:"where"})," are resolved to pipe functions, where ",(0,s.jsx)(n.code,{children:"length"})," takes\r\nno arguments and ",(0,s.jsx)(n.code,{children:"where"})," takes ",(0,s.jsx)(n.code,{children:"odd"})," as argument."]}),"\n",(0,s.jsx)(n.h2,{children:"Chaining pipe function"}),"\n",(0,s.jsx)(n.p,{children:"Pipe functions can chain indefinitely:"}),"\n",(0,s.jsx)(t,{data:{value:1},examples:["value + 1 concat foo upper"]}),"\n",(0,s.jsxs)(n.p,{children:["Here ",(0,s.jsx)(n.code,{children:"+"}),", ",(0,s.jsx)(n.code,{children:"concat"})," and ",(0,s.jsx)(n.code,{children:"upper"})," are resolved to pipe functions, each takes the previous value as input."]}),"\n",(0,s.jsx)(n.h2,{children:"Arguments to pipe function"}),"\n",(0,s.jsx)(n.p,{children:"There are four type of arguments in waterpipe:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["inferred: ",(0,s.jsx)(n.code,{children:"arg"})]}),"\n",(0,s.jsxs)(n.li,{children:["constant: ",(0,s.jsx)(n.code,{children:'"arg"'})," or ",(0,s.jsx)("code",{children:"`arg"})]}),"\n",(0,s.jsxs)(n.li,{children:["object path: ",(0,s.jsx)(n.code,{children:"$arg"})]}),"\n",(0,s.jsxs)(n.li,{children:["lambda: ",(0,s.jsx)(n.code,{children:"[ ... ]"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"When an argument is in inferred form, it follows the following steps:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"Numbers, booleans, undefined and null are always as constants"}),"\n",(0,s.jsxs)(n.li,{children:["If it is refers to an existing property or nested property of an existing property:","\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Input value"}),(0,s.jsx)(n.th,{children:"Resolved value"}),(0,s.jsx)(n.th,{children:"Accepted"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Object"}),(0,s.jsx)(n.td,{children:"Scalar"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Object"}),(0,s.jsx)(n.td,{children:"Object"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scalar"}),(0,s.jsx)(n.td,{children:"Scalar"}),(0,s.jsx)(n.td,{children:"\u2713"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Scalar"}),(0,s.jsx)(n.td,{children:"Object"}),(0,s.jsx)(n.td,{children:"Depends"})]})]})]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:"Constant string value"}),"\n"]}),"\n",(0,s.jsx)(t,{data:{scalar:"foo_",true:1,object:{a:1}},examples:["scalar & scalar","scalar & true","scalar & object"]}),"\n",(0,s.jsx)(n.p,{children:"See how it differs when the argument is in constant or object path form:"}),"\n",(0,s.jsx)(t,{data:{scalar:"foo_",true:1,object:{a:1}},examples:['scalar & "scalar"',"scalar & $true","scalar & $object"]}),"\n",(0,s.jsxs)(n.blockquote,{children:["\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Note"}),": Although constant argument are quoted by double quotes, they are coercied to booleans or Numbers\r\nif there can be coercied."]}),"\n"]}),"\n",(0,s.jsx)(t,{examples:['"1" + "2"']}),"\n",(0,s.jsx)(n.h2,{children:"Implicit input value"}),"\n",(0,s.jsx)(n.p,{children:"If the first argument is in inferred form and it does not resolve to a valid path,\r\nit will be inferred as pipe function, and it will take the current value as the input."}),"\n",(0,s.jsx)(t,{data:[1,2,3,4],examples:["sum","map [ + 1 ]"]}),"\n",(0,s.jsx)(n.h2,{children:"Constant or lambda as input value"}),"\n",(0,s.jsx)(n.p,{children:"Any pipe can also be started by a constant value or a lambda:"}),"\n",(0,s.jsx)(t,{examples:['"foo" upper','[ "foo" | "bar" ] join ,']})]})}function a(e,n){throw new Error("Expected "+(n?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}n.default=function(e={}){const{wrapper:n}=e.components||{};return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(t,e)})):t(e)}}}]);